---
layout: post
title: "Unanswerable Questions"
subtitle: "答不上来的问题"
date: 22020-12-18 20:59:10
author: "Axag"
header-img: "img/post-bg-unix-linux.jpg"
tags: [技术随写]
---
# 几个答不上来的问题
## 起因
一场我觉得比较愉快的聊天,的确能发现很多问题,工作这么多年把很多的东西都给忘记了,只能记得大概的模糊印象,要我具体去讲,还真讲不出来,所以保持总结书写是一个很有必要的习惯,现在也总结下几个印象比较深刻的问题
## 数据库范式(Normal Form) 及左连接和右连接
### 范式的作用
规范化的基本思想是逐步消除数据依赖中不合适的部分,使关系数据库模式的各关系模式达到某种程度的“分离”,即“一事一地”的模式设计原则.

### 几个名词释义
#### 平凡依赖
**定义：** 若X->Y，且Y是X的子集（对任一关系模式，平凡函数依赖必然成立），就是平凡函数依赖。
#### 非平凡依赖
**定义：** 若X->Y，但Y不是X的子集，就是非平凡函数依赖。
#### 部分函数依赖(部分依赖)
**定义：** 设X,Y是关系R的两个属性集合,存在X→Y,若X’是X的真子集,存在X’->Y,则称Y部分函数依赖于X.
**例子：** X=(a,b) Y 如果 a->Y 则称Y部分依赖于X
#### 完全函数依赖(完全依赖)
**定义：** 设X,Y是关系R的两个属性集合,X’是X的真子集,存在X->Y,但对每一个X’都有X’!->Y,则称Y完全函数依赖于X.
**例子：** X=(a,b) 如果a!->Y 和 b!->Y 则称为Y完全依赖于X
#### 传递函数依赖(传递依赖)
**定义：** 设X,Y,Z是关系R中互不相同的属性集合,存在X->Y(Y!->X),Y->Z,则称Z传递函数依赖于X.
**例子：** X=(a),Y=(b),Z=(c) 如果a->b,b->c,但是 b!->a,c!->b 那么c传递依赖于a
#### 元组
**定义：** 元组(tuple)是关系数据库中的基本概念,关系是一张表,表中的每行(即数据库中的每条记录)就是一个元组,每列就是一个属性. 在二维表里,元组也称为行.
#### 超码
**定义：** 一个或多个属性的集合,这些属性的组合可以使我们在一个关系中唯一地标识一个元组.
#### 候选码
**定义：** 超码这个集合中,如果提取它们的某个子集,这个子集是可以用来区分同一个表中的元组,且该子集只有一个元素或者再从中提取的子集无法用来区分同一个表中的元组,这个集合就是候选码.一个关系表中至少有一个候选码.
#### 主码
**定义：**  主码(primary key)是表中的一个或多个字段,它的值用于唯一的标识表中的某一条记录.
#### 主属性
**定义：** 在一个关系中,如果一个属性是构成某一个候选码的属性集中的一个属性,则称它为主属性(Prime attribute).
#### 非主属性
**定义：** 不包含在任何一个候选码中的属性称为非主属性.
#### 多值依赖
**定义：** 一个关系，至少存在三个属性（A、B、C），才能存在这种关系。对于每一个A值，有一组确定的B值和C值，并且这组B的值独立于这组C的值。

### 第一范式 (1NF)
**定义：**属性不可分(1NF是对属性的原子性约束,要求属性具有原子性,不可再分解).数据库表的每一列(也称为属性)都是不可分割的原子数据项,不能是集合,数组,记录等非原子数据项.实体中的某个属性有多个值时,必须拆分为不同的属性.在符合第一范式(1NF)表中的每个域值只能是实体的一个属性或一个属性的一部分.简而言之,第一范式就是无重复的域.

### 第二范式 (2NF)
**定义：**在满足第一范式(1NF)的基础上,每一个非码属性(不在主键中的列)都必须完全函数依赖于候选码.(2NF是对记录的惟一性约束,要求记录有惟一标识,即实体的惟一性,更通俗的说法就是一个表必须有主键ID).
超键:在关系模式中,能唯一标识元组的属性集称为超键.
候选键:如果一个属性集能唯一标识元组,且有不包含多余属性,那么这个属性集称为候选键;也即:候选键是没有多余属性的超键.
主键:关系模式中用户正在使用的候选键称主键

### 第三范式 (3NF)
**定义：**在满足第二范式(2NF)的基础上,每个非主属性不依赖于其它非主属性(即在2NF基础上,消除非码属性对候选码的传递函数依赖.3NF是对字段冗余性的约束,即任何字段不能递依赖于由其他字段派生出来,它要求字段没有冗余).
也就是说,任何非主属性都直接依赖于主属性,不能传递依赖于主属性.即表中的每一列只与主键直接相关,而不是间接相关(表中的每一列只能依赖于主键).每一个非码属性既不部分依赖于码,也不传码.

### 巴斯-科德范式 (BCNF)
**定义：**Boyce-Codd Normal Form(巴斯-科德范式)
某些特殊情况下,即使关系模式符合3NF的要求,仍然存在着插入异常,修改异常与删除异常的问题.BCNF由Boyce与Codd提出,通常被认为是修正的第三范式.
巴斯-科德范式即在满足第三范式(3NF)基础上,任何非主属性不能对主键子集依赖(即在3NF基础上,消除主属性对候选码的部分函数依赖和传递函数依赖).
BC范式既检查非主属性,又检查主属性.当只检查非主属性时,就成了第三范式.满足BC范式的关系都必然满足第三范式.或者还可以换一种说法：若一个关系达到了第三范式,并且它只有一个候选码,或者它的每个候选码都是单属性,则该关系自然达到BC范式.

### 第四范式 (4NF)
**定义：** 符合BC范式，并且不包含多值依赖关系。

### 第五范式/完美范式 (5NF)
**定义：** 如果关系模式R中的每一个连接依赖均由R的候选码所隐含，则称此关系模式符合第五范式。

#### 个人理解
就每个属性就不能再拆分出更细的属性,再实际设计表的时候,有发现用户地址,就单纯用个字符串,正常基于第一范式也要进行拆分,省,市,地址 这样进行拆分
现在只用一个属性当作主键那么肯定就符合第二范式,第二范式就是一定要有主键,并且所有属性完全依赖于主键. 当主键是由多个键组成,那么所有属性要完全依赖于这多个键,而不只依赖主键中的部分键
比如用户基础信息表, 这个用户属于多个部门,那么应该把部门单独抽一张表出来. 但是在这几年开发经历中,我们实际设计的时候的确会有冗余的设计,这样会更方便数据查询,唯一麻烦就是在更改的时候必须同时进行更新.
BCNF实际上是在第三范式的基础上,进一步消除了主属性的传递依赖,比如(A,B)-> C, C->A 这就是A对于(A,B)存在传递依赖

## 2.mvc与三层架构

## 3.线程之间的通讯

## 4.http tcp/udp socket  三次握手 四次分手

## 5. swift struct 与class区别 什么时候该用什么

## 6.面向对象 面向过程 函数式区别


## 7.AFNetwork  nsoperation
印象中AF并没有使用到NSOperation相关的 不过我也不确定,回来查了下源代码

谈一谈三种线程技术的区别和使用把

1.NSThread

2.GCD

3.NSOperation



## 8.测试的覆盖率的问题
这个这么多年开发 的确没经历过 也要补充下

